# 31.1_rpa
## Frontend Development | 1st website version of RPA

Here's a breakdown of the time and space complexities for each algorithm you mentioned:

1. **Insertion Sort**:

   - Time Complexity: \(O(n^2)\) in the worst-case scenario.
   - Space Complexity: \(O(1)\).

2. **Bubble Sort**:

   - Time Complexity: \(O(n^2)\) in the worst-case scenario.
   - Space Complexity: \(O(1)\).

3. **Merge Sort**:

   - Time Complexity: \(O(n \log n)\) in all cases (worst, average, and best).
   - Space Complexity: \(O(n)\) auxiliary space for the merge operation.

4. **Quick Sort**:

   - Time Complexity: \(O(n \log n)\) in the average case, \(O(n^2)\) in the worst-case scenario (rare but possible).
   - Space Complexity: \(O(\log n)\) due to recursive calls (stack space).

5. **Counting Sort**:

   - Time Complexity: \(O(n + k)\), where \(n\) is the number of elements in the input array and \(k\) is the range of the non-negative key values.
   - Space Complexity: \(O(n + k)\).

6. **Discrete Knapsack**:

   - Time Complexity: \(O(nW)\), where \(n\) is the number of items and \(W\) is the capacity of the knapsack.
   - Space Complexity: \(O(nW)\).

7. **Coin Change**:

   - Time Complexity: \(O(n \cdot m)\), where \(n\) is the number of coins and \(m\) is the amount to be changed.
   - Space Complexity: \(O(m)\).

8. **Rod Cutting**:

   - Time Complexity: \(O(n^2)\) with dynamic programming.
   - Space Complexity: \(O(n)\).

9. **Floyd Warshall Algorithm**:

   - Time Complexity: \(O(V^3)\) where \(V\) is the number of vertices.
   - Space Complexity: \(O(V^2)\).

10. **Rabin-Karp Algorithm**:
    - Time Complexity: \(O((n-m+1)m + nm)\), where \(n\) is the length of the text and \(m\) is the length of the pattern.
    - Space Complexity: \(O(1)\).

These complexities provide a general understanding of the efficiency of each algorithm in terms of time and space requirements.
